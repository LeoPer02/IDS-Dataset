# **IDS-Dataset project**

## **Table of Contents**
  - [**Background and Motivation**](#background-and-motivation)
  - [**Approaching the problem**](#approaching-the-problem)
    - [**Explaining the attacks:**](#explaining-the-attacks)
    - [**General Idea**](#general-idea)
      - [**Attacker Side**](#attacker-side)
      - [**Victim Side**](#victim-side)
  - [**Installation**](#installation)
    - [**Creating the virtual machine**](#creating-the-virtual-machine)
    - [**Setup Victim**](#setup-victim)
    - [**Setup Attacker**](#setup-attacker)
  - [**Troubleshooting**](#troubleshooting)
      - [**Executing the setup script throws an error during an apt/apt-get install:**](#executing-the-setup-script-throws-an-error-during-an-aptapt-get-install)
      - [**Server returns error when using custom module:**](#server-returns-error-when-using-custom-module)

## **Background and Motivation**

 <br/>
 
Intrusion Detection Systems are an important component of the security within of any system, therefore, is it imperative that this component is well trained.

For that purpose, [KDD](http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html) was initially developed and used, which consisted of 2 sets of data representative of "good" and "bad" connections, therefore simulating normal network traffic and intrusions by attackers, however, with time this dataset started losing it's use since it was developed in 1998 and 1999, used a Solaris-based system which is by no means widely used as of today and with the appearance of the so called Next Generation Attacks, that make one of their priorities to look as much as a normal process as possible, it slowly became less and less reliable to train current IDS.


For that purpose, the [UNSW University](https://www.unsw.edu.au/) developed a new dataset named [ADFA](https://research.unsw.edu.au/projects/adfa-ids-datasets) which was new and modern version of KDD that covered a lot of the most recent forms of attacks. This dataset consists of the system calls ID's detected during attacks.

**[Our](https://sigarra.up.pt/fcup/en/web_page.inicial) question was, can we improve this dataset by increasing the amount of information gathered about those system calls?**

In order to find that out, a project was created, in which my role was the following:
- Create a way to automate the process of attacks and the registering of the system calls generated by them.
- Compare the output of our auditing module with auditd.
- Compare the overhead produced by both auditing modules.

## **Approaching the problem**

---

**Some relevant information about the project:**
 - The project was developed on a Linux environment
 - In order to gather the system calls 2 modules were used, [our own module](https://github.com/fonsow/ebriareospf/tree/main/briareospf-master) developed by a MSc student and the [auditd Linux auditing System](https://linux.die.net/man/8/auditd)
 - The scripts in this repository were made in order to run in a very specific and controlled environment
 - All of the attacks were performed against a local machine for which due authorization was granted

The types of attacks used in the ADFA-LD were as following:

| Payload/Effect            | Vector                                    |
| :--------------------     | :------------                             |
| Password brute force      | FTP by Hydra                              |
| Password brute force      | SSH by Hydra                              |
| Add new superuser         | Client-side poisoned executable           |
| Java Based Meterpreter    | Tiki Wiki vulnerability exploit           |
| Linux Meterpreter Payload | Client-side poisoned executable           |
| C100 Web Shell            | PHP Remote File Inclusion Vulnerability   |

<br/>

Although this dataset is a very good representation of modern forms of attacks we decided to make some tweaks to the Attacks/Vectors of attack, and so we ended up with:

<br/>

| Payload/Effect                   | Vector                                    |
| :--------------------            | :------------                             |
| Password brute force             | FTP by Hydra                              |
| Password brute force             | SSH by Hydra                              |
| Docker Escape                    | Wordpress Wp File Manager exploit         |
| Linux Meterpreter Payload        | Client-side poisoned executable           |
| Web Shell (not necessarily C100) | PHP Remote File Inclusion Vulnerability   |
| LXD root file system mount       | Wordpress WP File Manager exploit

<br/>

### **Explaining the attacks:**
<br/>

> **üìù _NOTE:_** Docker escape, LXD root file system mount (and Linux Meterpreter Payload, although only for automation purposes) had as an entry point the Wordpress Wp File Manager vulnerability ([CVE-2020‚Äì25213](https://nvd.nist.gov/vuln/detail/CVE-2020-25213)).
>
> Also, detailed information about each attack can be found in it's respective folder.

<br/>

**FTP**/**SSH**: These brute force attacks were kept because even though they are a very noisy attack which is more then likely to be detected by any decently protected system, they still represented an available tool to any attacker, may that be an amateur or just a last case attack for an experienced attack.
For that purpose we used very well known tool [Hydra](https://www.kali.org/tools/hydra/).

**LXD Root File system Mount**: This attack consists of using a [payload](https://www.exploit-db.com/exploits/46978) against the [LXD software](https://linuxcontainers.org/lxd/introduction/) (system container and virtual machine manager for Linux systems) that allows us to mount the entire file system into a container, and accessing that container with root permissions, making it possible for an attacker to see, execute and modify every file in file system.

**Docker Escape**: Docker is a highly used container building platform which in a lot of cases is used to create isolation. Therefore, if an attacker wants to compromise the main system he needs to find a way to break that isolation. This a very interesting concept that we decided to study. There are some different ways to achieve this breach of isolation, between them we considered 2 options, using the docker socket to mount the host file system into a new container or using the Cgroup release agent vulnerability ([CVE-2022-0492](https://nvd.nist.gov/vuln/detail/cve-2022-0492)). We chose the latter since mounting the file system was an attack already implemented using LXD.

**Linux Meterpreter Payload**: This attack is a simulation of a Social Engineering attack, where we assume the user executed a poisoned file delivered through email or any other communication platform which establishes a meterpreter shell on the victim system (with reduced privileges).

**Web Shell**: We simulated a Remote File Inclusion vulnerability in the target website that allowed an attacker to pass as argument a URL that would be included, for that, the attacker would generate a web shell, in our case using [msfvenom](https://docs.metasploit.com/docs/using-metasploit/basics/how-to-use-msfvenom.html) and include it on the vulnerable page of the victim granting him a web shell.

**Extra:** We also added the option to only use the reverse shell through the WP File Manager vulnerability ([CVE-2020‚Äì25213](https://nvd.nist.gov/vuln/detail/CVE-2020-25213)). This is to automate the process of getting the reverse shell system call production. Since it's the entry point, being able to detect the attack in this phase would be highly beneficial.

<br/>

### **General Idea**

<br/>

#### **Attacker Side**
---
<br/>

The script should allow an user to perform an attack as fast and with as little interaction as possible, and preferably allowing the automation of the attacks

For that the user is prompted a series of questions that will generate a configuration file, this file will be used to automate the attacks.
Bellow we have a table with the possibilities for each attack:

<br/>

| Attack           | Repetition Mode   | Interactive Mode   | More Info     |
|:---------------- | :---------------: | :----------------: | :----------- |
| LXD attack       | &#9745;           | &#9745;            | User may use the attack in repeating mode or control the input given to the container       |
| FTP              | &#9745;           | &#9744;            | No interactive mode possible       |
| SSH              | &#9745;           | &#9744;            | Same as FTP       |
| Docker escape    | &#9745;           | &#9744;            | The exploit runs the commands in order to break isolation and then creates a proof of concept on ```/File_on_Host```. The user has no control over the process       |
| File Inclusion   | &#9745;           | &#9745;            | If ran on interactive mode the user is presented a web shell with interface on the web to execute commands       |
| Meterpreter Shell | &#9744;           | &#9745;            | This attacks requires the user to open msfconsole and interact with the meterpreter shell so no repetition mode was implemented       |
| Reverse Shell (Wp File Manager vulnerability) |  &#9745; | &#9744; |  Allows the user to gather the system calls of the entry point             |

> **üìù _NOTE:_** Detailed information for each attack can be found on its designated folder

<br/>

#### **Victim Side**
---
<br/>

To get the system calls and the additional information, we need a way to synchronize the attacks and the auditing.

For that purpose a simple http python server was implemented. This server is constantly listening for 1 out 2 requests:
- **/start?exploit={name_of_exploit}:** This GET request warns the server that the attack will begin shortly, and so the server, based on the name of the exploit, grabs the necessary PIDs to audit, and starts both auditing modules over those PIDs.
- **/stop?exploit={name_of_exploit}:** This GET request tells the server that the attack as ended, that way the server stops the auditing modules, grabs the output of both measurements and places them on the designated folder with the correct name, i.e. "Docker01.txt" and "audit_Docker01.txt".


<br/>

In the victim side we have also some other scripts such as overhead.sh, compare.py, etc, that are used in order to compare time and output of the modules.

More details in their respective folder README (**Aux**).

<br/>

## **Installation**
---
<br/>

**To help you setting up this project we provide the following steps:**

> **‚ö†Ô∏è _IMPORTANT:_** This project was developed and tested on a very specific set of conditions and we can not guarantee that the setup will be successful with any other set conditions, therefore it's highly recommended that you build this project on the following environment.

<br/>

### **Creating the virtual machine**
---

<br/>

For both machines, Virtual Box was used as the hypervisor, however you can use other hypervisors.

<br/>

For the victim machine [Ubuntu 18.04 Desktop](https://releases.ubuntu.com/18.04/) was used and for the attacker the [latest release of Kali](https://www.kali.org/get-kali/#kali-installer-images), since it comes with all the tools and files used on the attacks.

<br/>

After that, an important step is configuring the VMs in order for them to communicate between each another.

First create a new NAT Network.

In Virtual Box go to **File** -> **Tools** -> **Network Manager**

![image](https://github.com/LeoPer02/IDS-Dataset/assets/101013606/aa96f84c-e7d5-4e1a-85bf-5f47a033652c)

Go to **Nat Network** and create a new Network called Attack Network.

![image](https://github.com/LeoPer02/IDS-Dataset/assets/101013606/e739ccb1-c009-4ed7-a562-f9bf430a438b)

Add also the port fowarding.

![image](https://github.com/LeoPer02/IDS-Dataset/assets/101013606/213705f7-0b74-42c4-b761-37bce4b37e4d)


After that, on both machines, go to **Settings** -> **Network** -> **Adapter 1**

![image](https://github.com/LeoPer02/IDS-Dataset/assets/101013606/a9cd5f84-a54e-48c7-a92d-c8b1fd43aaec)

<br/>

That will enable you to connect both virtual machines and still have access to the internet.

<br/>

Now, for each VM you will execute it's respective setup script **as the root user**.

<br/>

### **Setup Victim**

<br/>

The ```setup_victim.sh``` script will download and configure the machine to replicate the one used during the project.

This script comes with some options:

<br/>

```
bash setup_victim.sh
```
With no flags the script will replicate the entire machine used during the project.

<br/>

```
bash setup_victim.sh -b
```
Installs everything except [bcc](https://github.com/iovisor/bcc/tree/master).
Using this flag will also disable the installation of our module, since [bcc](https://github.com/iovisor/bcc/tree/master) is one of it's dependencies.

This option should be used if you want to use your own module, which does not required bcc to run.

<br/>

```
bash setup_victim.sh -m
```
Will install everything except our module.

Use this if you intend to use your own auditing module instead of ours. Keep in mind this still installs [bcc](https://github.com/iovisor/bcc/tree/master).

<br/>

```
bash setup_victim.sh -q
```
This flag disables the output of the setup progress.

> **‚ö†Ô∏è _IMPORTANT:_** At the end of the script you will be presented with some steps needed to complete the setup process that could not be achieved with the script alone.


<br/>

### **Setup Attacker**

<br/>

In order to get the necessary tools to perform the attacks, the ```setup_attacker.sh ``` was created.

This script has the following options:

<br/>

``` Shell
bash setup_attacker.sh
```
With no flags, this will update Kali, install jq and remove victim setup files.

<br/>

``` Shell
bash setup_attacker.sh -k
```
With the **-k** flag the script will install all the tools used in the attackes that would come by default with Kali.

Use this flag if you're not using Kali, or any other penetration testing OS, as the attacker machine.

<br/>

``` Shell
bash setup_attacker.sh -q
```
This flag disables the output of the setup progress.

<br/>

## **Troubleshooting**
---
<br/>

**_During the development of this project we ran into some issues, and so, we decided to mention them here in the event the user runs into them_**
> **üìù _NOTE:_** For attack specific errors, check the README in their respective folder.
> 
<br/>

#### **Executing the setup script throws an error during an apt/apt-get install:**
 Try to run any apt/apt-get install command on the terminal, since the VM was just created there's a chance that some process is running apt in the background which got possession of the lock-frontend ([possible fix](https://askubuntu.com/questions/1109982/e-could-not-get-lock-var-lib-dpkg-lock-frontend-open-11-resource-temporari)).
If that is not the issue, check if the version of OS you're using is still supported, in the case of older versions, the source list used for the installation might be either corrupted or pointing to non-existent websites.

#### **Server returns error when using custom module:**
 The server initially was developed to run only our module but was then later adapted to run other possible modules. The explanation of how to do so can be seen using ```python3 server.py -h ``` however if you're still having issues with it, make sure the folder hierarchy is as follows:

``` Shell
# tree folder/with/module

/folder/with/module
‚îú‚îÄ‚îÄ file_module_1
...
‚îú‚îÄ‚îÄ file_module_n
‚îú‚îÄ‚îÄ server.py
‚îú‚îÄ‚îÄ start_module.sh
‚îú‚îÄ‚îÄ end_module.sh
‚îú‚îÄ‚îÄ data
|    ‚îú‚îÄ‚îÄ sys_exit.txt
|    ‚îú‚îÄ‚îÄ Dockercount.txt # With integer inside
|    ...
|    ‚îú‚îÄ‚îÄ LXDcount.txt # With integer inside


```
The server will try to create the files that it needs if they don't exist, however if for some reason it isn't able to, this should be the folder hierarchy. Also, make sure you're redirecting the output of your module to the ```sys_exit.txt``` file.


<br/>





